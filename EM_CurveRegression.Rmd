---
title: "EM_CurveRegression"
author: "HuanChen"
date: "2019/2/17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(splines)
library(splines2)
library(tidyverse)
```

```{r}
## N is the number of total points on the image
N = 300

## K is the number of total points on the curve 
K = 30

## The parameterization of the curve 
w <- seq(0, 2 * pi, by = 2 * pi / K)

## Generate of the Curve
X = 0
Y = 0
Z = 0
x.para = runif(1, -1, 1)
y.para = runif(1, -1, 1)
z.para = runif(1, -1, 1)
  
x = NULL
y = NULL
z = NULL
  
## Curve Generation with Spiral
coeff = runif(1, -2, 2)
X = X + x.para * w * sin(coeff * w)
Y = Y + y.para * w * cos(coeff * w)
Z = Z + z.para * w

for(k in 1 : K){
    x = c(x, X[k] + rnorm(10, 0, 0.1))
    y = c(y, Y[k] + rnorm(10, 0, 0.1))
    z = c(z, Z[k] + rnorm(10, 0, 0.1))
}

plot(x,y)
```

```{r}
## PI is the matrix of p_ik
PI = matrix(1 / K, nrow = N, ncol = K)
PI_sum = rep(1 / K, K)

## sigma is the variance of the noise in the gaussian distribution
sigma = 1

## beta_x and beta_y are the coefficients for the splines to the x-axis and y-axis
degree_free = 8
beta_x = runif(degree_free, 0, 1)
beta_y = runif(degree_free, 0, 1)

## Basis for the spline
w <- seq(0, 2 * pi, by = 2 * pi / K)
B = bs(w, df = degree_free)

for(t in 1 : 100){
  ## E-step
  for(i in 1 : N){
    for(k in 1 : K){
      PI[i,k] = exp(-1 / (2 * sigma) * (x[i] - B[k, ] %*% beta_x) ^ 2 + (y[i] - B[k, ] %*%   beta_y)^ 2) * PI_sum[k]
    }
    PI = PI / apply(PI, 1, sum)
  }

  ## M-step
  ## Update PI_sum
  PI_sum = 1 / N * apply(PI, 2, sum)

  ## Update sigma
  sigma_temp = 0
  for(i in 1 : N){
    for(j in 1 : K){
      sigma_temp = sigma_temp + ((x[i] - B[k, ] %*% beta_x)^2 + (y[i] - B[k, ] %*% beta_y)^2) * PI[i,k]
    }
  }
  sigma_temp = sigma_temp / N
  sigma = sigma_temp

  ## Update beta_x and beta_y
  X = c()
  Y = c()
  B_X = c()
  B_Y = c()
  for(i in 1 : N){
    for(k in 1 : K){
      X = c(X, x[i] * sqrt(PI[i, k]))
      Y = c(Y, y[i] * sqrt(PI[i, k]))
      B_X = rbind(B_X, B[k, ] * sqrt(PI[i, k]))
      B_Y = rbind(B_Y, B[k, ] * sqrt(PI[i, k]))
    }
  }
  beta_x  = solve(t(B_X) %*% B_X) %*% t(B_X) %*% X
  beta_y  = solve(t(B_Y) %*% B_Y) %*% t(B_Y) %*% Y

## Computation of the log likelihood
index_max = apply(PI, 1, which.max)
log_likelihood = -N / 2 * log(sigma)
for(i in 1 : N){
  log_likelihood = log_likelihood - ((x[i] - B[index_max[i], ] %*% beta_x)^2 + (y[i] - B[index_max[i], ] %*% beta_y)^2)/ (2 * sigma)
}
print(log_likelihood)
}


```


